"""
This type stub file was generated by pyright.
"""

import click
from click_default_group import DefaultGroup

CONTEXT_SETTINGS = ...
VALID_COLUMN_TYPES = ...
UNICODE_ERROR = ...
field_size_limit = ...
def output_options(fn):
    ...

def load_extension_option(fn):
    ...

@click.group(cls=DefaultGroup, default="query", default_if_no_args=True, context_settings=CONTEXT_SETTINGS)
@click.version_option()
def cli(): # -> None:
    "Commands for interacting with a SQLite database"
    ...

@cli.command()
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.option("--fts4", help="Just show FTS4 enabled tables", default=False, is_flag=True)
@click.option("--fts5", help="Just show FTS5 enabled tables", default=False, is_flag=True)
@click.option("--counts", help="Include row counts per table", default=False, is_flag=True)
@output_options
@click.option("--columns", help="Include list of columns for each table", is_flag=True, default=False)
@click.option("--schema", help="Include schema for each table", is_flag=True, default=False)
@load_extension_option
def tables(path, fts4, fts5, counts, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, columns, schema, load_extension, views=...): # -> None:
    """List the tables in the database"""
    ...

@cli.command()
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.option("--counts", help="Include row counts per view", default=False, is_flag=True)
@output_options
@click.option("--columns", help="Include list of columns for each view", is_flag=True, default=False)
@click.option("--schema", help="Include schema for each view", is_flag=True, default=False)
@load_extension_option
def views(path, counts, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, columns, schema, load_extension): # -> None:
    """List the views in the database"""
    ...

@cli.command()
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("tables", nargs=-1)
@click.option("--no-vacuum", help="Don't run VACUUM", default=False, is_flag=True)
@load_extension_option
def optimize(path, tables, no_vacuum, load_extension): # -> None:
    """Optimize all full-text search tables and then run VACUUM - should shrink the database file"""
    ...

@cli.command(name="rebuild-fts")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("tables", nargs=-1)
@load_extension_option
def rebuild_fts(path, tables, load_extension): # -> None:
    """Rebuild all or specific full-text search tables"""
    ...

@cli.command()
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
def vacuum(path): # -> None:
    """Run VACUUM against the database"""
    ...

@cli.command()
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@load_extension_option
def dump(path, load_extension): # -> None:
    """Output a SQL dump of the schema and full contents of the database"""
    ...

@cli.command(name="add-column")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("col_name")
@click.argument("col_type", type=click.Choice(["integer", "float", "blob", "text", "INTEGER", "FLOAT", "BLOB", "TEXT"]), required=False)
@click.option("--fk", type=str, required=False, help="Table to reference as a foreign key")
@click.option("--fk-col", type=str, required=False, help="Referenced column on that foreign key table - if omitted will automatically use the primary key")
@click.option("--not-null-default", type=str, required=False, help="Add NOT NULL DEFAULT 'TEXT' constraint")
@load_extension_option
def add_column(path, table, col_name, col_type, fk, fk_col, not_null_default, load_extension): # -> None:
    "Add a column to the specified table"
    ...

@cli.command(name="add-foreign-key")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("column")
@click.argument("other_table", required=False)
@click.argument("other_column", required=False)
@click.option("--ignore", is_flag=True, help="If foreign key already exists, do nothing")
@load_extension_option
def add_foreign_key(path, table, column, other_table, other_column, ignore, load_extension): # -> None:
    """
    Add a new foreign key constraint to an existing table. Example usage:

        $ sqlite-utils add-foreign-key my.db books author_id authors id

    WARNING: Could corrupt your database! Back up your database file first.
    """
    ...

@cli.command(name="add-foreign-keys")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("foreign_key", nargs=-1)
@load_extension_option
def add_foreign_keys(path, foreign_key, load_extension): # -> None:
    """
    Add multiple new foreign key constraints to a database. Example usage:

    \b
    sqlite-utils add-foreign-keys my.db \\
        books author_id authors id \\
        authors country_id countries id
    """
    ...

@cli.command(name="index-foreign-keys")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@load_extension_option
def index_foreign_keys(path, load_extension): # -> None:
    """
    Ensure every foreign key column has an index on it.
    """
    ...

@cli.command(name="create-index")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("column", nargs=-1, required=True)
@click.option("--name", help="Explicit name for the new index")
@click.option("--unique", help="Make this a unique index", default=False, is_flag=True)
@click.option("--if-not-exists", help="Ignore if index already exists", default=False, is_flag=True)
@load_extension_option
def create_index(path, table, column, name, unique, if_not_exists, load_extension): # -> None:
    """
    Add an index to the specified table covering the specified columns.
    Use "sqlite-utils create-index mydb -- -column" to specify descending
    order for a column.
    """
    ...

@cli.command(name="enable-fts")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("column", nargs=-1, required=True)
@click.option("--fts4", help="Use FTS4", default=False, is_flag=True)
@click.option("--fts5", help="Use FTS5", default=False, is_flag=True)
@click.option("--tokenize", help="Tokenizer to use, e.g. porter")
@click.option("--create-triggers", help="Create triggers to update the FTS tables when the parent table changes.", default=False, is_flag=True)
@load_extension_option
def enable_fts(path, table, column, fts4, fts5, tokenize, create_triggers, load_extension): # -> None:
    "Enable full-text search for specific table and columns"
    ...

@cli.command(name="populate-fts")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("column", nargs=-1, required=True)
@load_extension_option
def populate_fts(path, table, column, load_extension): # -> None:
    "Re-populate full-text search for specific table and columns"
    ...

@cli.command(name="disable-fts")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@load_extension_option
def disable_fts(path, table, load_extension): # -> None:
    "Disable full-text search for specific table"
    ...

@cli.command(name="enable-wal")
@click.argument("path", nargs=-1, type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@load_extension_option
def enable_wal(path, load_extension): # -> None:
    "Enable WAL for database files"
    ...

@cli.command(name="disable-wal")
@click.argument("path", nargs=-1, type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@load_extension_option
def disable_wal(path, load_extension): # -> None:
    "Disable WAL for database files"
    ...

@cli.command(name="enable-counts")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("tables", nargs=-1)
@load_extension_option
def enable_counts(path, tables, load_extension): # -> None:
    "Configure triggers to update a _counts table with row counts"
    ...

@cli.command(name="reset-counts")
@click.argument("path", type=click.Path(exists=True, file_okay=True, dir_okay=False, allow_dash=False), required=True)
@load_extension_option
def reset_counts(path, load_extension): # -> None:
    "Reset calculated counts in the _counts table"
    ...

def insert_upsert_options(fn):
    ...

def insert_upsert_implementation(path, table, json_file, pk, nl, flatten, csv, tsv, delimiter, quotechar, sniff, no_headers, batch_size, alter, upsert, ignore=..., replace=..., truncate=..., not_null=..., default=..., encoding=..., detect_types=..., load_extension=..., silent=...): # -> None:
    ...

@cli.command()
@insert_upsert_options
@click.option("--ignore", is_flag=True, default=False, help="Ignore records if pk already exists")
@click.option("--replace", is_flag=True, default=False, help="Replace records if pk already exists")
@click.option("--truncate", is_flag=True, default=False, help="Truncate table before inserting records, if table already exists")
def insert(path, table, json_file, pk, nl, flatten, csv, tsv, delimiter, quotechar, sniff, no_headers, batch_size, alter, encoding, detect_types, load_extension, silent, ignore, replace, truncate, not_null, default): # -> None:
    """
    Insert records from JSON file into a table, creating the table if it
    does not already exist.

    Input should be a JSON array of objects, unless --nl or --csv is used.
    """
    ...

@cli.command()
@insert_upsert_options
def upsert(path, table, json_file, pk, nl, flatten, csv, tsv, batch_size, delimiter, quotechar, sniff, no_headers, alter, not_null, default, encoding, detect_types, load_extension, silent): # -> None:
    """
    Upsert records based on their primary key. Works like 'insert' but if
    an incoming record has a primary key that matches an existing record
    the existing record will be updated.
    """
    ...

@cli.command(name="create-table")
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("columns", nargs=-1, required=True)
@click.option("--pk", help="Column to use as primary key")
@click.option("--not-null", multiple=True, help="Columns that should be created as NOT NULL")
@click.option("--default", multiple=True, type=(str, str), help="Default value that should be set for a column")
@click.option("--fk", multiple=True, type=(str, str, str), help="Column, other table, other column to set as a foreign key")
@click.option("--ignore", is_flag=True, help="If table already exists, do nothing")
@click.option("--replace", is_flag=True, help="If table already exists, replace it")
@load_extension_option
def create_table(path, table, columns, pk, not_null, default, fk, ignore, replace, load_extension): # -> None:
    """
    Add a table with the specified columns. Columns should be specified using
    name, type pairs, for example:

    \b
    sqlite-utils create-table my.db people \\
        id integer \\
        name text \\
        height float \\
        photo blob --pk id
    """
    ...

@cli.command(name="drop-table")
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.option("--ignore", is_flag=True)
@load_extension_option
def drop_table(path, table, ignore, load_extension): # -> None:
    "Drop the specified table"
    ...

@cli.command(name="create-view")
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("view")
@click.argument("select")
@click.option("--ignore", is_flag=True, help="If view already exists, do nothing")
@click.option("--replace", is_flag=True, help="If view already exists, replace it")
@load_extension_option
def create_view(path, view, select, ignore, replace, load_extension): # -> None:
    "Create a view for the provided SELECT query"
    ...

@cli.command(name="drop-view")
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("view")
@click.option("--ignore", is_flag=True)
@load_extension_option
def drop_view(path, view, ignore, load_extension): # -> None:
    "Drop the specified view"
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("sql")
@click.option("--attach", type=(str, click.Path(file_okay=True, dir_okay=False, allow_dash=False)), multiple=True, help="Additional databases to attach - specify alias and filepath")
@output_options
@click.option("-r", "--raw", is_flag=True, help="Raw output, first column of first row")
@click.option("-p", "--param", multiple=True, type=(str, str), help="Named :parameters for SQL query")
@load_extension_option
def query(path, sql, attach, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, raw, param, load_extension): # -> None:
    "Execute SQL query and return the results as JSON"
    ...

@cli.command()
@click.argument("paths", type=click.Path(file_okay=True, dir_okay=False, allow_dash=True), required=False, nargs=-1)
@click.argument("sql")
@click.option("--attach", type=(str, click.Path(file_okay=True, dir_okay=False, allow_dash=False)), multiple=True, help="Additional databases to attach - specify alias and filepath")
@output_options
@click.option("-r", "--raw", is_flag=True, help="Raw output, first column of first row")
@click.option("-p", "--param", multiple=True, type=(str, str), help="Named :parameters for SQL query")
@click.option("--encoding", help="Character encoding for CSV input, defaults to utf-8")
@click.option("-n", "--no-detect-types", is_flag=True, help="Treat all CSV/TSV columns as TEXT")
@click.option("--schema", is_flag=True, help="Show SQL schema for in-memory database")
@click.option("--dump", is_flag=True, help="Dump SQL for in-memory database")
@click.option("--save", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), help="Save in-memory database to this file")
@click.option("--analyze", is_flag=True, help="Analyze resulting tables and output results")
@load_extension_option
def memory(paths, sql, attach, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, raw, param, encoding, no_detect_types, schema, dump, save, analyze, load_extension): # -> None:
    """Execute SQL query against an in-memory database, optionally populated by imported data

    To import data from CSV, TSV or JSON files pass them on the command-line:

    \b
        sqlite-utils memory one.csv two.json \\
            "select * from one join two on one.two_id = two.id"

    For data piped into the tool from standard input, use "-" or "stdin":

    \b
        cat animals.csv | sqlite-utils memory - \\
            "select * from stdin where species = 'dog'"

    The format of the data will be automatically detected. You can specify the format
    explicitly using :json, :csv, :tsv or :nl (for newline-delimited JSON) - for example:

    \b
        cat animals.csv | sqlite-utils memory stdin:csv places.dat:nl \\
            "select * from stdin where place_id in (select id from places)"

    Use --schema to view the SQL schema of any imported files:

    \b
        sqlite-utils memory animals.csv --schema
    """
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("dbtable")
@click.argument("q")
@click.option("-o", "--order", type=str, help="Order by ('column' or 'column desc')")
@click.option("-c", "--column", type=str, multiple=True, help="Columns to return")
@click.option("--limit", type=int, help="Number of rows to return - defaults to everything")
@click.option("--sql", "show_sql", is_flag=True, help="Show SQL query that would be run")
@click.option("--quote", is_flag=True, help="Apply FTS quoting rules to search term")
@output_options
@load_extension_option
@click.pass_context
def search(ctx, path, dbtable, q, order, show_sql, quote, column, limit, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, load_extension): # -> None:
    "Execute a full-text search against this table"
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("dbtable")
@click.option("-c", "--column", type=str, multiple=True, help="Columns to return")
@output_options
@load_extension_option
@click.pass_context
def rows(ctx, path, dbtable, column, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, load_extension): # -> None:
    "Output all rows in the specified table"
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("tables", nargs=-1)
@output_options
@load_extension_option
@click.pass_context
def triggers(ctx, path, tables, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, load_extension): # -> None:
    "Show triggers configured in this database"
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("tables", nargs=-1)
@click.option("--aux", is_flag=True, help="Include auxiliary columns")
@output_options
@load_extension_option
@click.pass_context
def indexes(ctx, path, tables, aux, nl, arrays, csv, tsv, no_headers, table, fmt, json_cols, load_extension): # -> None:
    "Show indexes for this database"
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("tables", nargs=-1, required=False)
@load_extension_option
def schema(path, tables, load_extension): # -> None:
    "Show full schema for this database or for specified tables"
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.option("--type", type=(str, click.Choice(["INTEGER", "TEXT", "FLOAT", "BLOB"], case_sensitive=False)), multiple=True, help="Change column type to INTEGER, TEXT, FLOAT or BLOB")
@click.option("--drop", type=str, multiple=True, help="Drop this column")
@click.option("--rename", type=(str, str), multiple=True, help="Rename this column to X")
@click.option("-o", "--column-order", type=str, multiple=True, help="Reorder columns")
@click.option("--not-null", type=str, multiple=True, help="Set this column to NOT NULL")
@click.option("--not-null-false", type=str, multiple=True, help="Remove NOT NULL from this column")
@click.option("--pk", type=str, multiple=True, help="Make this column the primary key")
@click.option("--pk-none", is_flag=True, help="Remove primary key (convert to rowid table)")
@click.option("--default", type=(str, str), multiple=True, help="Set default value for this column")
@click.option("--default-none", type=str, multiple=True, help="Remove default from this column")
@click.option("--drop-foreign-key", type=str, multiple=True, help="Drop this foreign key constraint")
@click.option("--sql", is_flag=True, help="Output SQL without executing it")
@load_extension_option
def transform(path, table, type, drop, rename, column_order, not_null, not_null_false, pk, pk_none, default, default_none, drop_foreign_key, sql, load_extension): # -> None:
    "Transform a table beyond the capabilities of ALTER TABLE"
    ...

@cli.command()
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("columns", nargs=-1, required=True)
@click.option("--table", "other_table", help="Name of the other table to extract columns to")
@click.option("--fk-column", help="Name of the foreign key column to add to the table")
@click.option("--rename", type=(str, str), multiple=True, help="Rename this column in extracted table")
@load_extension_option
def extract(path, table, columns, other_table, fk_column, rename, load_extension): # -> None:
    "Extract one or more columns into a separate table"
    ...

@cli.command(name="insert-files")
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table")
@click.argument("file_or_dir", nargs=-1, required=True, type=click.Path(file_okay=True, dir_okay=True, allow_dash=True))
@click.option("-c", "--column", type=str, multiple=True, help="Column definitions for the table")
@click.option("--pk", type=str, help="Column to use as primary key")
@click.option("--alter", is_flag=True, help="Alter table to add missing columns")
@click.option("--replace", is_flag=True, help="Replace files with matching primary key")
@click.option("--upsert", is_flag=True, help="Upsert files with matching primary key")
@click.option("--name", type=str, help="File name to use")
@click.option("--text", is_flag=True, help="Store file content as TEXT, not BLOB")
@click.option("--encoding", help="Character encoding for input, defaults to utf-8")
@click.option("-s", "--silent", is_flag=True, help="Don't show a progress bar")
@load_extension_option
def insert_files(path, table, file_or_dir, column, pk, alter, replace, upsert, name, text, encoding, silent, load_extension): # -> None:
    """
    Insert one or more files using BLOB columns in the specified table

    Example usage:

    \b
    sqlite-utils insert-files pics.db images *.gif \\
        -c name:name \\
        -c content:content \\
        -c content_hash:sha256 \\
        -c created:ctime_iso \\
        -c modified:mtime_iso \\
        -c size:size \\
        --pk name
    """
    ...

@cli.command(name="analyze-tables")
@click.argument("path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False, exists=True), required=True)
@click.argument("tables", nargs=-1)
@click.option("-c", "--column", "columns", type=str, multiple=True, help="Specific columns to analyze")
@click.option("--save", is_flag=True, help="Save results to _analyze_tables table")
@load_extension_option
def analyze_tables(path, tables, columns, save, load_extension): # -> None:
    "Analyze the columns in one or more tables"
    ...

@cli.command(help=_generate_convert_help())
@click.argument("db_path", type=click.Path(file_okay=True, dir_okay=False, allow_dash=False), required=True)
@click.argument("table", type=str)
@click.argument("columns", type=str, nargs=-1, required=True)
@click.argument("code", type=str)
@click.option("--import", "imports", type=str, multiple=True, help="Python modules to import")
@click.option("--dry-run", is_flag=True, help="Show results of running this against first 10 rows")
@click.option("--multi", is_flag=True, help="Populate columns for keys in returned dictionary")
@click.option("--where", help="Optional where clause")
@click.option("-p", "--param", multiple=True, type=(str, str), help="Named :parameters for where clause")
@click.option("--output", help="Optional separate column to populate with the output")
@click.option("--output-type", help="Column type to use for the output column", default="text", type=click.Choice(["integer", "float", "blob", "text"]))
@click.option("--drop", is_flag=True, help="Drop original column afterwards")
@click.option("-s", "--silent", is_flag=True, help="Don't show a progress bar")
def convert(db_path, table, columns, code, imports, dry_run, multi, where, param, output, output_type, drop, silent): # -> None:
    ...

class UnicodeDecodeErrorForPath(Exception):
    def __init__(self, exception, path) -> None:
        ...
    


FILE_COLUMNS = ...
def output_rows(iterator, headers, nl, arrays, json_cols): # -> Generator[str, None, None]:
    ...

def maybe_json(value): # -> str | Any:
    ...

def json_binary(value): # -> dict[str, Unknown]:
    ...

